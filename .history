tag Left true as (Left Bool | Right Nat)
:t tag Left true as (Left Bool | Right Nat)
(\f:Nat -> Nat.f 0) (\n:Nat.S n)
:t (\f:Nat -> Nat.f 0)
:t (\f:Nat -> Nat.f 0))
:t (\n:Nat.S n)
:t (\p:Bool.if: p then: 1 else: 0)
(\p:Bool.if: p then: 1 else: 0) True
(\p:Bool.if: p then: 1 else: 0) False
(\n:Nat.S n) 2
(\n:Nat.S n) 1
(\n:Nat.S n) 0
(\n:Nat.S n)
let x = {foo=1, bar=False} in get x[foo]
let x = {foo=1, bar=False} in (get x[foo])
let x = True in x
let x True in x
get {foo=1, baz=1, bam=True}[bam]
get {foo=1, baz=1, bam=True}[baz]
get {foo=1, baz=1, bam=True}[foo]
{foo=1, baz=1, bam=True}
{foo=1, baz=1, bam=True]
{foo=1, baz=1, bam=True]
{foo=1, baz=1, bam=True]
:t (True, 0, False, 0)
:t (True, 0, False)
:t (True, 0)
(True, 0)
:t 4
4
3
2
1
0
:t True
False
True
(tag Left Unit as (Left Nat | Right Bool))
(tag Right True as (Left Nat | Right Bool))
(tag Right True as (Left Nat | Right Bool))
(tag Right 0 as (Left Nat | Right Bool))
(tag Left 0 as (Left Nat | Right Bool))
(tag Left Nat as (Left Nat | Right Bool))
(tag Left Unit as (Left Nat | Right Bool))
(tag Left Unit as (Left Nat | Right Bool))
(tag Left Unit as (Left Nat | Right Bool))
(tag Left Unit as (Left Nat | Right Bool))
(tag Let Unit as (Left Nat | Right Bool))
(tag Right Unit as (Left Nat | Right Bool))
(tag Right 0 as (Left Nat | Right Bool))
(tag Right (1, True) as (Left Unit | Right (Nat, Bool)))
{foo=1, foo=True}
(tag Right 0 as (Left Nat | Right Bool))
<1, <2, <3, Unit>>>
<1, <2, <3, Nil>>>
<1, <2, <3, 4>>>
(1,2,3,True)
(1,2,3,4)
<1, 2, 3>
:t <1, 2>
<1, 2>
<1, 2
(True as Unit)
(True as Bool)
True
(tag Right 0 as (Left Nat | Right Bool))
(tag Right 0 as (Left Nat | Right Bool)
(tag Right (1, True) as (Left Unit | Right (Nat, Bool)))
(tag Right (1, True) as (Left Unit | Right (Nat, Bool)))
:t (1, True)
tag Right (1, True) as (Left Unit | Right (Nat Bool))
tag Right (1, True) as (Left Unit | Right (Nat, Bool))
tag Right (1, True) as (Left Unit | Right (Nat, Bool)
(\val: Left Unit | Right Nat.variantCase val of Left=x => False | Right=n => True) (tag Right 1 as (Left Unit | Right Nat))
(\val: Left Unit | Right Nat.variantCase val of Left=x => False | Right=n => True) (tag Left Unit as (Left Unit | Right Nat))
:t (\val: Left Unit | Right Nat.variantCase val of Left=x => False | Right=n => True) (tag Left Unit as (Left Unit | Right Nat))
:t (\val: Left Unit | Right Nat.variantCase val of Left=x => False | Right=n => True)
:t (\val: Left Unit | Right Nat.variantCase val of Left x => False | Right n => True)
:t (\val: Left Unit | Right Nat.caseVarient val of Left x => False | Right n => True)
:t (\val: Left Unit | Right Nat.varientCase val of Left x => False | Right n => True)
:t (\val: Left Unit | Right Nat.case val of Left x => False | Right n => True)
:t (\val: Left Unit | Right Nat.case val of Left x => False | Right n => True)
:t (\val: Left Unit | Right Nat.val)
(\val: Left Unit | Right Nat.val)
:t tag Right 0 as Left Nat | Right Bool
tag Right 0 as Left Nat | Right Bool
tag Right True as Left Nat | Right Bool
tag Left 0 as Left Nat | Right Bool
:t tag Left 0 as Left Nat | Right Bool
tag Left 0 as Left Nat | Right Bool
tag Left 0 as Left Nat | Right Bool
(Left 0 as Left Nat | Right Bool)
Left 0 as (Left Nat | Right Bool)
Left 0 as (Left Nat | Right Bool)
{foo=True, foo=1}
(get {foo=True, foo=1}
(get {foo=True, bar=1, baz=(\n:Nat.S n)}[baz]) 2
(get {foo=True, bar=1, baz=(\n:Nat.S n)}[baz]) 1
(get {foo=True, bar=1, baz=(\n:Nat.S n)}[baz]) 0
get {foo=True, bar=1, baz=(\n:Nat.S n)}[baz]
