:t (tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
:t (tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
:t (tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
(tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
(tag Cons (3, tag Cons (2, tag Cons (1, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
tag Branch (tag Leaf, 0, tag Branch (tag Leaf, 1, tag Leaf)) as mu.NatTree: Leaf | Branch (NatTree, Nat, NatTree)
{foo=True, bar= 7}
(1, 2)
(1, 2)
{foo=True, bar= 7}
{foo=True, bar= 7}
(1, 2)
tag Branch (tag Leaf, 0, tag Branch (tag Leaf, 1, tag Leaf)) as mu.NatTree: Leaf | Branch (NatTree, Nat, NatTree)
(tag Cons (3, tag Cons (2, tag Cons (1, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
:t {foo=True, bar= 7}
{foo=True, bar= 7}
:t let x = {foo=inr True : Sum Nat Bool, bar=4} in x
let x = {foo=inr True : Sum Nat Bool, bar=4} in x
let x = {foo=inr True : Sum Nat Bool, bar=4} in x
:t let x = {foo=inr True : Sum Nat Bool, bar=4} in x
:r
:t let x = {foo=inr True : Sum Nat Bool, bar=4} in x
let x = {foo=inr True : Sum Nat Bool, bar=4} in x
let x = {foo=inr True : Sum Nat Bool} in x
:t let x = {foo=inr True : Sum Nat Bool} in x
:t [True, 1]
:t True
:t let x = {foo=inr True : Sum Nat Bool} in x
:t let x = {foo=inr True : Sum Nat Bool} in x
:t let x = {foo=inr True : Sum Nat Bool} in x
:t let x = {foo=inr True : Sum Nat Bool} in x
let x = {foo=inr True : Sum Nat Bool} in x
let x = {foo=inr True : Sum Nat Bool} in (get x.foo)
:t (tag Right [1, True] as (Left Unit | Right [Nat, Bool]))
(tag Right [1, True] as (Left Unit | Right [Nat, Bool]))
(tag Right [1, True] as (Left Unit | Right (Nat, Bool)))
(tag Right (1, True) as (Left Unit | Right (Nat, Bool)))
S True
S S 8
8
S ((\n:Nat.n) Z)
S ((\n:Nat.n) Z)
S True
:t let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec isEven(rec : Nat -> Bool) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) in isEven 4
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec isEven(rec : Nat -> Bool) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) in isEven 4
:t variantCase (tag Just 1 as Nothing | Just Nat) of Nothing => Z | Just=x => x
variantCase (tag Just 1 as Nothing | Just Nat) of Nothing => Z | Just=x => x
(tag Cons [3, tag Cons [2, tag Cons [1, tag Nil]]] as mu.NatList: Nil | Cons [Nat, NatList])
(tag Cons [3, tag Cons [2, tag Cons [1, tag Nil]]] as mu.NatList: Nil | Cons [Nat, NatList]))
  \p:Nat.p
(Nothing as Nothing | Just Nat)
variantCase (Nothing as Nothing | Just Nat) of Nothing => False | Just=x => True
get {foo=True}.foo
get [True, False].1
get [True, False].0
get [True, False].0
get {foo=True}.foo
get {foo=True}[foo]
get {foo=True}[foo]
{foo=True}
get {foo=True}[foo]
get {foo=True}["foo"]
get [True, False]
get [True, False]["0"]
get [True, False][0]
[True, False]
:t case Z of Z => Z | S m => Z
case Z of Z => Z | S m => Z
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec isEven(rec : Nat -> Bool) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) in isEven 3
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec isEven(rec : Nat -> Bool) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) in isEven 4
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec isEven(rec : Nat -> Bool) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) in isEven 3
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec isEven(rec : Nat -> Bool) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) in isEven 4
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec isEven(rec : Nat -> Bool) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) in isEven 2
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec isEven(rec : Nat -> Bool) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) in isEven 3
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec isEven(rec : Nat -> Bool) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) in True
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec isEven(rec : Nat -> Nat) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) in True
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec isEven(rec : Nat -> Nat) (n : Nat) = if: isZero n then: True else: if isZero (pred n) then: False else: rec (pred (pred n)) in True
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec (rec : Nat -> Nat) (n : Nat) = if: isZero n then: True else: if isZero (pred n) then: False else: rec (pred (pred n)) in True
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in isZero (pred 2)
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in isZero (pred 1)
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in pred 3
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in pred 2
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in pred 1
let isZero (n : Nat) = case n of Z => True | (S m) => False in letrec isEven (rec : Nat -> Nat) (n : Nat) = case n of Z => True | (S m) => case m of Z => False | (S l) => rec l in isEven 0
let isZero (n : Nat) = case n of Z => True | (S m) => False in isZero 3
let isZero (n : Nat) = case n of Z => True | (S m) => False in isZero 1
let isZero (n : Nat) = case n of Z => True | (S m) => False in isZero 0
let isZero (n : Nat) = case n of Z => True | (S m) => False in isZero 0
letrec isZero (n : Nat) = case n of Z => True | (S m) => False in isZero 0
letrec isZero (rec : Nat -> Nat) (n : Nat) = case n of Z => True | (S m) => rec m in isZero 0
letrec isZero (rec : Nat -> Nat) (a : Nat) = a in isZero 0
letrec isZero (rec : Nat -> Nat) (a : Nat) = a in isZero
let isZero (a : Nat) = a
letrec isZero (rec) (a) = a
letrec isZero (rec : Nat -> Nat) (a : Nat) = a
letrec
(\v:(Nothing | Just Nat).variantCase v of Nothing => False | Just=x => True) (tag Just 4 as (Nothing | Just Nat))
(\v:(Nothing | Just Nat).variantCase v of Nothing => False | Just=x => True) (tag Nothing as (Nothing | Just Nat))
:t (\v:(Nothing | Just Nat).variantCase v of Nothing => False | Just=x => True)
(\v:(Nothing | Just Nat).variantCase v of Nothing => False | Just=x => True)
