:t tag Nothing as (Nothing | Just Nat)
tag Nothing as (Nothing | Just Nat)
tag Nothing as (Nothing | Just Nat)
tag Nothing (Nothing | Just Nat)
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False) (tag Nothing as (Nothing | Just Nat))
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False) (tag Nothing Unit as (Nothing | Just Nat))
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False) (tag Nothing Unit as (Nothing | Just Nat))
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False) (Notag thing Unit as (Nothing | Just Nat))
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False) (Nothing Unit as (Nothing | Just Nat))
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing => True)
(\val:Nothing | Just Nat.variantCase val of Nothing => True)
(\val:Nothing | Just Nat.variantCase val of Nothing => True)
(\val:Nothing | Just Nat.variantCase val of Nothing=z => True)
(\val:Nothing | Just Nat.variantCase val of Nothing=z => True | Just=x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing=z => True | Just=x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing=z => True | Just=x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False)
(\val:Nothing | Just Nat.val)
(\val:Nothing | Just Nat).val)
tag Left true as (Left Bool | Right Nat)
:t tag Left true as (Left Bool | Right Nat)
(\f:Nat -> Nat.f 0) (\n:Nat.S n)
:t (\f:Nat -> Nat.f 0)
:t (\f:Nat -> Nat.f 0))
:t (\n:Nat.S n)
:t (\p:Bool.if: p then: 1 else: 0)
(\p:Bool.if: p then: 1 else: 0) True
(\p:Bool.if: p then: 1 else: 0) False
(\n:Nat.S n) 2
(\n:Nat.S n) 1
(\n:Nat.S n) 0
(\n:Nat.S n)
let x = {foo=1, bar=False} in get x[foo]
let x = {foo=1, bar=False} in (get x[foo])
let x = True in x
let x True in x
get {foo=1, baz=1, bam=True}[bam]
get {foo=1, baz=1, bam=True}[baz]
get {foo=1, baz=1, bam=True}[foo]
{foo=1, baz=1, bam=True}
{foo=1, baz=1, bam=True]
{foo=1, baz=1, bam=True]
{foo=1, baz=1, bam=True]
:t (True, 0, False, 0)
:t (True, 0, False)
:t (True, 0)
(True, 0)
:t 4
4
3
2
1
0
:t True
False
True
(tag Left Unit as (Left Nat | Right Bool))
(tag Right True as (Left Nat | Right Bool))
(tag Right True as (Left Nat | Right Bool))
(tag Right 0 as (Left Nat | Right Bool))
(tag Left 0 as (Left Nat | Right Bool))
(tag Left Nat as (Left Nat | Right Bool))
(tag Left Unit as (Left Nat | Right Bool))
(tag Left Unit as (Left Nat | Right Bool))
(tag Left Unit as (Left Nat | Right Bool))
(tag Left Unit as (Left Nat | Right Bool))
(tag Let Unit as (Left Nat | Right Bool))
(tag Right Unit as (Left Nat | Right Bool))
(tag Right 0 as (Left Nat | Right Bool))
(tag Right (1, True) as (Left Unit | Right (Nat, Bool)))
{foo=1, foo=True}
(tag Right 0 as (Left Nat | Right Bool))
<1, <2, <3, Unit>>>
<1, <2, <3, Nil>>>
<1, <2, <3, 4>>>
(1,2,3,True)
(1,2,3,4)
<1, 2, 3>
:t <1, 2>
<1, 2>
<1, 2
(True as Unit)
(True as Bool)
True
(tag Right 0 as (Left Nat | Right Bool))
(tag Right 0 as (Left Nat | Right Bool)
(tag Right (1, True) as (Left Unit | Right (Nat, Bool)))
(tag Right (1, True) as (Left Unit | Right (Nat, Bool)))
:t (1, True)
tag Right (1, True) as (Left Unit | Right (Nat Bool))
tag Right (1, True) as (Left Unit | Right (Nat, Bool))
tag Right (1, True) as (Left Unit | Right (Nat, Bool)
(\val: Left Unit | Right Nat.variantCase val of Left=x => False | Right=n => True) (tag Right 1 as (Left Unit | Right Nat))
(\val: Left Unit | Right Nat.variantCase val of Left=x => False | Right=n => True) (tag Left Unit as (Left Unit | Right Nat))
