(1,2,3,4)
tag Nil as (mu. ListNat (Nil | Cons [Nat, ListNat]))
tag Nil as (mu. ListNat (Nil | Cons [Nat, ListNat]))
tag Nil as (mu. ListNat (Nil | Cons [Nat, ListNat]))
tag Nil as (mu. ListNat (Nil | Cons [Nat, ListNat]))
tag Nil as (mu. ListNat (Nil | Cons [Nat, ListNat]))
tag Nil as (mu. ListNat (Nil | Cons [Nat, ListNat]))
tag Nil as (mu. ListNat (Nil | Cons [Nat, ListNat]))
tag Nil as (mu. ListNat (Nil | Cons [Nat, ListNat]))
tag Nil as (mu. ListNat (Nil | Cons [Nat, ListNat]))
tag Nil as (mu. ListNat (Nil | Cons [Nat, ListNat]))
tag Nil as (mu. ListNat (Nil | Cons [Nat, ListNat]))
tag Nil as (mu. ListNat Nil | Cons [Nat, ListNat])
tag Nil as (mu. ListNat Nil | Cons (Nat, ListNat))
let xs = tag Nil as (mu. ListNat Nil | Cons (Nat, ListNat)) in xs
(1,2,3,4)
:t (\x:Nothing | Just Nat. x)
(\x:Nothing | Just Nat. x)
(\x:Nat.x) 1
(\x:Nat.x)
(x:Nat.x)
let x = 1 in x
<1, True, True>
<1, True>
Unit
tag Just 1 as (Nothing | Just Nat)
:t tag Nothing as (Nothing | Just Nat)
tag Nothing as (Nothing | Just Nat)
tag Nothing Z as (Nothing Nat | Just Nat)
:t { foo=True, baz=False }
:t { foo=True, baz=False }
{ foo=True, baz=False }
:t (1, True, 1)
:t (1, True)
(1, True)
tag Nothing Z as (Nothing Nat | Just Nat)
tag Nothing Z as (Nothing Just | Just Nat)
tag Nothing as (Nothing Just | Just Nat)
:r
tag Nothing as (Nothing | Just Nat)
tag Nothing as (Nothing | Just)
tag Nothing as (Nothing | Just Nat)
tag Left Z as (Left Nat | Right Bool)
tag Monday Unit as Monday | Tuesday
tag Monday Unit as (Monday | Tuesday)
tag Monday as (Monday | Tuesday)
inl Unit : Sum Unit Nat
inl Unit : (Sum Unit Nat)
inl Unit as (Sum Unit Nat)
tag Nothing as (Nothing | Just Nat)
tag Just 1 as (Nothing | Just Nat)
tag Just 1 as (Nothing | Just Int)
tag Just 1 as (Nothing | Just Nat)
tag Left True as (Left Bool | Right Nat)
:t (\val:Left Bool | Right Nat.variantCase val of Left=p => p | Right=n => True)
:t tag Just 1 as (Nothing | Just Int)
False
True
true
tag Just 1 as (Nothing | Just Int)
tag Nothing as (Nothing | Just Int)
(\n:Nat.let f (m : Nat) = S m in f n) 0
:t (\n:Nat.let f (m : Nat) = S m in f n)
:t (\p:Bool.\n:Nat.n)
:t (\p:Bool.p)
(\p:Bool.p)
:t (\n:Nat.let f (m : Nat) = S m in f n)
:t (\n:Nat.let f (m : Nat) = S m in f n))
:t (\p:Bool.\n:Nat.n)
:t (\p:Bool.p)
(\p:Bool.p)
:t(\p:Bool.p)
(\p:Bool.p)
:t (\val:Left Bool | Right Nat.variantCase val of Left=p => p | Right=n => True)
(\val:Left Bool | Right Nat.variantCase val of Left=p => p | Right=n => True)
:t (\val:Left Bool | Right Nat.variantCase val of Left=p => p | Right=n => True)
:t (\val:Left Bool | Right Nat.variantCase val of Left=p => p | Right=n => True)
(\val:(Left Bool | Right Nat).val)
(\val:(Left Bool | Just Nat).val)
(\val:Left Bool | Just Nat.val)
(\val:Nothing | Just Nat.val)
:t (\val:Left Bool | Right Nat.variantCase val of Left=p => 0 | Right=n => n)
:t (\val:(Left Bool | Right Nat).variantCase val of Left=p => 0 | Right=n => n)
(\val:(Left Bool | Right Nat).variantCase val of Left=p => 0 | Right=n => n)
(\val:Nothing | Just Nat.variantCase val of Nothing => 0 | Just=n => n)
(\val:Nothing | Just Nat.val)
(\val:Nothing | Just Nat.val))
(\val:(Nothing | Just Nat).val))
(\val:(Nothing | Just Nat).variantCase val of Nothing => 0 | Just=n => n)
(\val:(Nothing | Just Nat).variantCase val of Nothing => 0 | Just=n => S n)
:t tag Just 2 as (Nothing | Just Nat)
tag Just 2 as (Nothing | Just Nat)
tag Nothing as (Nothing | Just Nat)
:t tag Left True as (Left Bool | Right Nat)
tag Left True as (Left Bool | Right Nat)
get {foo=True, bar=1}[foo]
:t {foo=True, bar=1}
{foo=True, bar=1}
:t (True, 1)
(True, 1)
