(\n:Nat.let f (m : Nat) = S m in f n) 0
:t (\n:Nat.let f (m : Nat) = S m in f n)
:t (\p:Bool.\n:Nat.n)
:t (\p:Bool.p)
(\p:Bool.p)
:t (\n:Nat.let f (m : Nat) = S m in f n)
:t (\n:Nat.let f (m : Nat) = S m in f n))
:t (\p:Bool.\n:Nat.n)
:t (\p:Bool.p)
(\p:Bool.p)
:t(\p:Bool.p)
(\p:Bool.p)
:t (\val:Left Bool | Right Nat.variantCase val of Left=p => p | Right=n => True)
(\val:Left Bool | Right Nat.variantCase val of Left=p => p | Right=n => True)
:t (\val:Left Bool | Right Nat.variantCase val of Left=p => p | Right=n => True)
:t (\val:Left Bool | Right Nat.variantCase val of Left=p => p | Right=n => True)
(\val:(Left Bool | Right Nat).val)
(\val:(Left Bool | Just Nat).val)
(\val:Left Bool | Just Nat.val)
(\val:Nothing | Just Nat.val)
:t (\val:Left Bool | Right Nat.variantCase val of Left=p => 0 | Right=n => n)
:t (\val:(Left Bool | Right Nat).variantCase val of Left=p => 0 | Right=n => n)
(\val:(Left Bool | Right Nat).variantCase val of Left=p => 0 | Right=n => n)
(\val:Nothing | Just Nat.variantCase val of Nothing => 0 | Just=n => n)
(\val:Nothing | Just Nat.val)
(\val:Nothing | Just Nat.val))
(\val:(Nothing | Just Nat).val))
(\val:(Nothing | Just Nat).variantCase val of Nothing => 0 | Just=n => n)
(\val:(Nothing | Just Nat).variantCase val of Nothing => 0 | Just=n => S n)
:t tag Just 2 as (Nothing | Just Nat)
tag Just 2 as (Nothing | Just Nat)
tag Nothing as (Nothing | Just Nat)
:t tag Left True as (Left Bool | Right Nat)
tag Left True as (Left Bool | Right Nat)
get {foo=True, bar=1}[foo]
:t {foo=True, bar=1}
{foo=True, bar=1}
:t (True, 1)
(True, 1)
:t Unit
:t 2
:t True
Unit
3
2
1
False
True
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False) (tag Nothing as (Nothing | Just Nat))
tag Nothing as (Nothing | Just Nat)
:t tag Nothing as (Nothing | Just Nat)
tag Nothing as (Nothing | Just Nat)
tag Nothing as (Nothing | Just Nat)
tag Nothing (Nothing | Just Nat)
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False) (tag Nothing as (Nothing | Just Nat))
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False) (tag Nothing Unit as (Nothing | Just Nat))
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False) (tag Nothing Unit as (Nothing | Just Nat))
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False) (Notag thing Unit as (Nothing | Just Nat))
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False) (Nothing Unit as (Nothing | Just Nat))
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing => True)
(\val:Nothing | Just Nat.variantCase val of Nothing => True)
(\val:Nothing | Just Nat.variantCase val of Nothing => True)
(\val:Nothing | Just Nat.variantCase val of Nothing=z => True)
(\val:Nothing | Just Nat.variantCase val of Nothing=z => True | Just=x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing=z => True | Just=x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing=z => True | Just=x => False)
(\val:Nothing | Just Nat.variantCase val of Nothing => True | Just=x => False)
(\val:Nothing | Just Nat.val)
(\val:Nothing | Just Nat).val)
tag Left true as (Left Bool | Right Nat)
:t tag Left true as (Left Bool | Right Nat)
(\f:Nat -> Nat.f 0) (\n:Nat.S n)
:t (\f:Nat -> Nat.f 0)
:t (\f:Nat -> Nat.f 0))
:t (\n:Nat.S n)
:t (\p:Bool.if: p then: 1 else: 0)
(\p:Bool.if: p then: 1 else: 0) True
(\p:Bool.if: p then: 1 else: 0) False
(\n:Nat.S n) 2
(\n:Nat.S n) 1
(\n:Nat.S n) 0
(\n:Nat.S n)
let x = {foo=1, bar=False} in get x[foo]
let x = {foo=1, bar=False} in (get x[foo])
let x = True in x
let x True in x
get {foo=1, baz=1, bam=True}[bam]
get {foo=1, baz=1, bam=True}[baz]
get {foo=1, baz=1, bam=True}[foo]
{foo=1, baz=1, bam=True}
{foo=1, baz=1, bam=True]
{foo=1, baz=1, bam=True]
{foo=1, baz=1, bam=True]
:t (True, 0, False, 0)
