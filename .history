(\n:Nat.n) 1
(tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
(tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec isEven(rec : Nat -> Bool) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) in isEven 5
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec isEven(rec : Nat -> Bool) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) in isEven 4 
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec isEven(rec : Nat -> Bool) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) in isEven 4
   in letrec isEven(rec : Nat -> Bool) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) 
   in let pred (n : Nat) = case n of Z => Z | (S m) => m 
let isZero (n : Nat) = case n of Z => True | (S m) => False 
:t tag Just 32 as (Nothing | Just Nat)
:t tag Nothing as (Nothing | Just Nat)
tag Nothing as (Nothing | Just Nat)
:t (1, True, True)
:t (1, True)
(1, True)
:t 4
4
3
2
1
:t True
False
True
:t Unit
let x = {foo=tag Nothing as (Nothing | Just Nat)} in (get x.foo)
:t tag Nothing as (Nothing | Just Nat)
:t tag Nothing as (Nothing | Just Nat)
:t tag Nothing sa (Nothing | Just Nat)
:t tag Nothing (Nothing | Just Nat)
let x = {foo=tag Nothing as (Nothing | Just Nat)} in (get x.foo)
:t let x = {foo=tag Nothing as (Nothing | Just Nat)} in (get x.foo)
:t let x = {foo=tag Nothing as (Nothing | Just Nat)} in (get x.foo)
let x = {foo=tag Nothing as (Nothing | Just Nat)} in (get x.foo)
get {foo=tag Nothing as (Nothing | Just Nat)}.foo
get {foo=1}.foo
get {foo=1}.foo
{foo=1}.foo
{foo=tag Nothing as (Nothing | Just Nat)}.foo
let x = {foo=tag Nothing as (Nothing | Just Nat)} in (x)
let x = {foo=tag Nothing as (Nothing | Just Nat)} in (get x)
let x = {foo=tag Nothing as (Nothing | Just Nat)} in (get x.foo)
let x = {foo=Nothing as (Nothing | Just Nat)} in (get x.foo)
:r
:t tag Branch (tag Leaf, 0, tag Branch (tag Leaf, 1, tag Leaf)) as mu.NatTree: Leaf | Branch (NatTree, Nat, NatTree)
tag Branch (tag Leaf, 0, tag Branch (tag Leaf, 1, tag Leaf)) as mu.NatTree: Leaf | Branch (NatTree, Nat, NatTree)
:t (tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
(tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
:t tag Branch (tag Leaf, 0, tag Branch (tag Leaf, 1, tag Leaf)) as mu.NatTree: Leaf | Branch (NatTree, Nat, NatTree)
tag Branch (tag Leaf, 0, tag Branch (tag Leaf, 1, tag Leaf)) as mu.NatTree: Leaf | Branch (NatTree, Nat, NatTree)
:t (tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
:t (tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
:t (tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
:t (tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
:t {foo=True, bar= 7}
:t (\x:(Nothing | Just Nat).variantCase x of Nothing => 0 | Just=y => y) (tag Just 2 as (Nothing | Just Nat))
(\x:(Nothing | Just Nat).variantCase x of Nothing => 0 | Just=y => y) (tag Just 2 as (Nothing | Just Nat))
(\x:(Nothing | Just Nat).variantCase x of Nothing => 0 | Just=y => y) (tag Just 2 as (Nothing | Just Nat))
:t {foo=True, bar= 7}
:t{foo=True, bar= 7}
{foo=True, bar= 7}
:t tag Branch (tag Leaf, 0, tag Branch (tag Leaf, 1, tag Leaf)) as mu.NatTree: Leaf | Branch (NatTree, Nat, NatTree)
tag Branch (tag Leaf, 0, tag Branch (tag Leaf, 1, tag Leaf)) as mu.NatTree: Leaf | Branch (NatTree, Nat, NatTree)
:t (tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
:t (tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
:t (tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
:t (tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
(tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
(tag Cons (3, tag Cons (2, tag Cons (1, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
tag Branch (tag Leaf, 0, tag Branch (tag Leaf, 1, tag Leaf)) as mu.NatTree: Leaf | Branch (NatTree, Nat, NatTree)
{foo=True, bar= 7}
(1, 2)
(1, 2)
{foo=True, bar= 7}
{foo=True, bar= 7}
(1, 2)
tag Branch (tag Leaf, 0, tag Branch (tag Leaf, 1, tag Leaf)) as mu.NatTree: Leaf | Branch (NatTree, Nat, NatTree)
(tag Cons (3, tag Cons (2, tag Cons (1, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
:t {foo=True, bar= 7}
{foo=True, bar= 7}
:t let x = {foo=inr True : Sum Nat Bool, bar=4} in x
let x = {foo=inr True : Sum Nat Bool, bar=4} in x
let x = {foo=inr True : Sum Nat Bool, bar=4} in x
:t let x = {foo=inr True : Sum Nat Bool, bar=4} in x
:r
:t let x = {foo=inr True : Sum Nat Bool, bar=4} in x
let x = {foo=inr True : Sum Nat Bool, bar=4} in x
let x = {foo=inr True : Sum Nat Bool} in x
:t let x = {foo=inr True : Sum Nat Bool} in x
:t [True, 1]
:t True
:t let x = {foo=inr True : Sum Nat Bool} in x
:t let x = {foo=inr True : Sum Nat Bool} in x
:t let x = {foo=inr True : Sum Nat Bool} in x
:t let x = {foo=inr True : Sum Nat Bool} in x
let x = {foo=inr True : Sum Nat Bool} in x
let x = {foo=inr True : Sum Nat Bool} in (get x.foo)
:t (tag Right [1, True] as (Left Unit | Right [Nat, Bool]))
(tag Right [1, True] as (Left Unit | Right [Nat, Bool]))
(tag Right [1, True] as (Left Unit | Right (Nat, Bool)))
(tag Right (1, True) as (Left Unit | Right (Nat, Bool)))
