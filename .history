:t (\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
((\n:Nat.S n) 0, (\m:Nat.S m) 0)
((\n:Nat.S n), (\m:Nat.S m) 0)
((\n:Nat.S n), (\m:Nat.S m))
((\n:Nat.S n), \m:Nat.S m)
(\n:Nat.S n, \m:Nat.S m)
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
:t (\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
:t (\val:Left Nat | Right Bool.variantCase val of Left=n => n | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
:t (\val:Left Nat | Right Bool.variantCase val of Left=n => n | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
:t (\val:Left Nat | Right Bool.variantCase val of Left=n => n | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
:t (\val:Left Bool | Right Bool.variantCase val of Left=n => n | Right=p => Z)
:t (\val:Left Bool | Right Bool.variantCase val of Left=n => n | Right=p => Z)
:t (\val:Left Nat | Right Bool.variantCase val of Left=n => n | Right=p => Z) (tag Left Z as (Left Nat | Right Bool))
:t (\val:Left Nat | Right Bool.variantCase val of Left=n => n | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
:t (\val:Left Nat | Right Bool.variantCase val of Left=n => True | Right=p => p) (tag Left Z as (Left Nat | Right Nat))
:t (\val:Left Nat | Right Bool.variantCase val of Left=n => True | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
(\val:Left Nat | Right Bool.variantCase val of Left=n => True | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
(\val:Left Nat | Right Bool.variantCase val of Left=n => True | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
:t (\val:Left Nat | Right Bool.variantCase val of Left=n => True | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
(\val:Left Nat | Right Bool.variantCase val of Left=n => True | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
(\val:Left Nat | Right Bool.variantCase val of Left=n => True | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
:t (\val:Left Nat | Right Bool.variantCase val of Left=n => True | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
:t (Left Z as Left Nat | Right Bool)
:t (Left Z as (Left Nat | Right Bool))
:t (\val:Left Nat | Right Bool.variantCase val of Left=n => True | Right=p => p) (Left Z as (Left Nat | Right Bool))
:t (\val:Left Nat | Right Bool.variantCase val of Left=n => True | Right=p => p)
:t (\val:Left Nat | Right Bool.variantCase val of Left n => True | Right p => p)
(\val:Left Nat | Right Bool.val)
:t (\val:Left Nat | Right Bool.val)
:t tag Left 1 as (Left Nat | Right Bool)
tag Left 1 as (Left Nat | Right Bool)
tag Left 1 as (Left Nat | Right Bool)
:t tag Left 1 as (Left Nat | Right Bool)
:t tag Left 1 as (Left Nat | Right Bool)
tag Left 1 as (Left Nat | Right Bool)
tag Left 1 as (Left Nat | Right Bool)
tag Left 1 as (Left Nat | Right Bool)
:t tag Left 1 as (Left Nat | Right Bool)
:r
:r
tag Left 1 as Left Nat | Right Bool
:t tag Left 1 as Left Nat | Right Bool
:t tag Left 1 as (Left Nat | Right Bool)
tag Left 1 as (Left Nat | Right Bool)
:t tag Left Z as (Left Bool | Right Bool)
:t tag Left Z as (Left Bool | Right Bool)
:t tag Left Z as (Left Bool | Right Bool)
:t tag Left Z as (Left Bool | Right Bool)
tag Left Z as (Left Bool | Right Bool)
:t tag Left Z as (Left Bool | Right Bool)
:t tag Left Z as (Left Bool | Right Bool)
:t tag Left Z as (Left Bool | Right Bool)
tag
tag Left Z as (Left Bool | Right Bool)
tag Left Z as (Left Bool | Right Bool)
tag Left Z as (Left Nat | Right Bool)
tag Left Nat as (Left Nat | Right Bool)
:t tag Left Nat as (Left Nat | Right Bool)
:t Left Nat as (Left Nat | Right Bool)
:t Left Nat (Left Nat | Right Bool)
:t (\n:Left Nat | Right Bool.variantCase n of Left=x => (\z:Nat.True) x | Right=y => (\w:Bool.w) y)
:t (\n:Left Nat | Right Bool.variantCase n of Left=x => (\z:Nat.True) x | Right=y => (\w:Bool.w) y)
:t (\n:Left Nat | Right Bool.variantCase n of Left=x => (\z:Nat.True) | Right=y => (\w:Bool.w))
:t (\n:Left Nat | Right Bool.variantCase n of Left=x => ((\z:Nat.True) x))
:t (\n:Left Nat | Right Bool.variantCase n of Left=x => ((\z:Nat.True) x))
:t (\n:Left Nat | Right Bool.variantCase n of Left=x => ((\z:Nat.True) n))
:t (\n:Left Nat | Right Bool.variantCase n of Left=x => ((\z:Nat.True) Z))
:t (\n:Left Nat | Right Bool.variantCase n of Left=x => ((\z:Nat.True) x))
:t (\n:Left Nat | Right Bool.variantCase n of Left=x => (\z:Nat.True) x)
:t (\n:Left Nat | Right Bool.variantCase n of Left=x => (\z:Nat.True))
:t (\n:Left Nat | Right Bool.variantCase n of Left=x => (\z:Nat.True) | Right=y => (\w:Bool.w))
:t (\n:Left Nat | Right Bool.variantCase n of Left=x => ((\z:Nat.True) x) | Right=y => ((\w:Bool.w) y))
:t (\n:Left Nat | Right Bool.variantCase n of Left=x => (\z:Nat.True) x | Right=y => (\w:Bool.w) y)
:t (\n:Left Nat | Right Bool.variantCase n of Left=x => True | Right=y => Z)
:t (\n:Left Nat | Right Bool.variantCase n of Left=x => True | Right=y => False)
:t (\n:Left Nat | Right Bool.variantCase n of Left=x => True | Right=y => False))
:t (\n:Left Nat | Right Bool.variantCase n of Left x => True | Right y => False))
:t (\n:Left Nat | Right Bool.n)
(\n:Left Nat | Right Bool.n)
:t (\z:Nat.\q:Nat.q)
(\z:Nat.\q:Nat.q)
(\f:Nat->Nat.\n:Nat.let x = case n of Z => (\z:Nat.\q:Nat.n) | (S m) => (\h:Nat.\z:Nat.m) in n)
(\f:Nat->Nat.\n:Nat.let x = case n of Z => (\z:Nat.\q:Nat.n) | (S m) => (\h:Nat.\z:Nat.m) in x)
(\f:Nat->Nat.\n:Nat.let x = case n of Z => (\z:Nat.\q:Nat.n) | (S m) => (\h:Nat.\z:Nat.m) in x)
(\f:Nat->Nat.\n:Nat.let x = case n of Z => (\z:Nat.\q:Nat.n) | (S m) => (\h:Nat.\z:Nat.m) in x)
(\f:Nat->Nat.\n:Nat.let x = case n of Z => (\z:Nat.\q:Nat.n) | (S m) => (\h:Nat.\z:Nat.m) in x)
(\f:Nat->Nat.\n:Nat.let x = case n of Z => (\z:Nat.\q:Nat.n) | (S m) => (\h:Nat.\z:Nat.m) in x)
(\f:Nat->Nat.\n:Nat.let x = case n of Z => (\z:Nat.\q:Nat.n) | (S m) => (\h:Nat.\z:Nat.m) in x)
(\f:Nat->Nat.\n:Nat.let x = case n of Z => (\z:Nat.\q:Nat.n) | (S m) => (\h:Nat.\z:Nat.m) in x)
(\f:Nat->Nat.\n:Nat.let x = case n of Z => (\z:Nat.\q:Nat.n) | (S m) => (\h:Nat.\z:Nat.m) in x)
(\f:Nat->Nat.\n:Nat.let x = case n of Z => (\z:Nat.\q:Nat.n) | (S m) => (\h:Nat.\z:Nat.m) in x)
(\f:Nat->Nat.\n:Nat.let x = case n of Z => n | (S m) => m in x)
(\f:Nat->Nat.\n:Nat.let x = case n of Z => n | (S m) => m in x)
(\f:Nat->Nat.\n:Nat.let x = case n of Z => n | (S m) => m in )
(\f:Nat->Nat.\n:Nat.let x = case n of Z => (\z:Nat.\q:Nat.n) | (S m) => (\h:Nat.\z:Nat.m) in x)
(\f:Nat->Nat.\n:Nat.let x = case n of Z => (\z:Nat.\q:Nat.n) | (S m) => (\h:Nat.\z:Nat.m) in f x)
