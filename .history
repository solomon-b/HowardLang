(tag Left Nat as (Left Nat | Right Bool))
(tag Left Unit as (Left Nat | Right Bool))
(tag Left Unit as (Left Nat | Right Bool))
(tag Left Unit as (Left Nat | Right Bool))
(tag Left Unit as (Left Nat | Right Bool))
(tag Let Unit as (Left Nat | Right Bool))
(tag Right Unit as (Left Nat | Right Bool))
(tag Right 0 as (Left Nat | Right Bool))
(tag Right (1, True) as (Left Unit | Right (Nat, Bool)))
{foo=1, foo=True}
(tag Right 0 as (Left Nat | Right Bool))
<1, <2, <3, Unit>>>
<1, <2, <3, Nil>>>
<1, <2, <3, 4>>>
(1,2,3,True)
(1,2,3,4)
<1, 2, 3>
:t <1, 2>
<1, 2>
<1, 2
(True as Unit)
(True as Bool)
True
(tag Right 0 as (Left Nat | Right Bool))
(tag Right 0 as (Left Nat | Right Bool)
(tag Right (1, True) as (Left Unit | Right (Nat, Bool)))
(tag Right (1, True) as (Left Unit | Right (Nat, Bool)))
:t (1, True)
tag Right (1, True) as (Left Unit | Right (Nat Bool))
tag Right (1, True) as (Left Unit | Right (Nat, Bool))
tag Right (1, True) as (Left Unit | Right (Nat, Bool)
(\val: Left Unit | Right Nat.variantCase val of Left=x => False | Right=n => True) (tag Right 1 as (Left Unit | Right Nat))
(\val: Left Unit | Right Nat.variantCase val of Left=x => False | Right=n => True) (tag Left Unit as (Left Unit | Right Nat))
:t (\val: Left Unit | Right Nat.variantCase val of Left=x => False | Right=n => True) (tag Left Unit as (Left Unit | Right Nat))
:t (\val: Left Unit | Right Nat.variantCase val of Left=x => False | Right=n => True)
:t (\val: Left Unit | Right Nat.variantCase val of Left x => False | Right n => True)
:t (\val: Left Unit | Right Nat.caseVarient val of Left x => False | Right n => True)
:t (\val: Left Unit | Right Nat.varientCase val of Left x => False | Right n => True)
:t (\val: Left Unit | Right Nat.case val of Left x => False | Right n => True)
:t (\val: Left Unit | Right Nat.case val of Left x => False | Right n => True)
:t (\val: Left Unit | Right Nat.val)
(\val: Left Unit | Right Nat.val)
:t tag Right 0 as Left Nat | Right Bool
tag Right 0 as Left Nat | Right Bool
tag Right True as Left Nat | Right Bool
tag Left 0 as Left Nat | Right Bool
:t tag Left 0 as Left Nat | Right Bool
tag Left 0 as Left Nat | Right Bool
tag Left 0 as Left Nat | Right Bool
(Left 0 as Left Nat | Right Bool)
Left 0 as (Left Nat | Right Bool)
Left 0 as (Left Nat | Right Bool)
{foo=True, foo=1}
(get {foo=True, foo=1}
(get {foo=True, bar=1, baz=(\n:Nat.S n)}[baz]) 2
(get {foo=True, bar=1, baz=(\n:Nat.S n)}[baz]) 1
(get {foo=True, bar=1, baz=(\n:Nat.S n)}[baz]) 0
get {foo=True, bar=1, baz=(\n:Nat.S n)}[baz]
get {foo=True, bar=1, baz=(\n:Nat.S n)}[bar]
get {foo=True, bar=1, baz=(\n:Nat.S n)}[foo]
:t {foo=True, bar=1, baz=(\n:Nat.S n)}
{foo=True, bar=1, baz=(\n:Nat.S n)}
{foo=True, bar=1, baz=(\n:Nat.S n)}
:t (1,True,  False)
(1,True,  False)
(1,True)
Unit
let f = (\n:Nat.S n) in f 5
let f = (\n:Nat.S n) in f 4
let f = (\n:Nat.S n) in f 3
let f = (\n:Nat.S n) in f 2
let f = (\n:Nat.S n) in f 1
let f = (\n:Nat.S n) in f 0
let f = (\n:Nat.S n) in f
let x = 0 in S x
let x = 0 in x
:t (\f:Nat->Bool.f Z)
:t 3
:t True
True
Trye
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => True) (tag Left Z as (Left Nat | Right Bool))
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => True) (tag Right True as (Left Nat | Right Bool))
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => ((\n:Nat.True) 1)) (tag Right True as (Left Nat | Right Bool))
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => ((\n:Nat.True) 1)) (tag Left Z as (Left Nat | Right Bool))
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => ((\n:Nat.True) 1)) (tag Left Z as (Left Nat | Right Bool))
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => ((\n:Nat.True) 1)) (tag Left Z as (Left Nat | Right Bool))
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => (\n:Nat.True) 1) (tag Left Z as (Left Nat | Right Bool))
:t (\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => (\n:Nat.True) 1) (tag Left Z as (Left Nat | Right Bool))
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => (\n:Nat.True) 1) (tag Left Z as (Left Nat | Right Bool))
:t (\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => (\n:Nat.False) 1)
:t (\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => (\n:Nat.False))
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => (\n:Nat.False) 1)
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => (\n:Nat.False) Z)
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => (\n:Nat.False) Z)
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => (\n:Nat.False))
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => p)
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => p)
(\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
:t (\val:Left Nat | Right Bool.variantCase val of Left=n => False | Right=p => p) (tag Left Z as (Left Nat | Right Bool))
