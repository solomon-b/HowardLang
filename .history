get {foo=1, bar=(\n:Nat.True) 1}.foo
{foo=1, bar=(\n:Nat.True) 1}
case 1 of Z=> True | (S m) => False
case 1 of Z=> True | (S m) => False
case Z of Z=> True | (S m) => False
case Z of Z=> True | (S m) => False
{foo=1, bar=(\n:Nat.True) 1}
{foo=1, bar=(\n:Nat.True)}
{foo=1, bar=(\n:Nat.True) 1}
(1, (\n:Nat.True) 1 )
(1, (\n:Nat.True) 1 )
(1, (\n:Nat.True))
(1, True)
tag (\u:Unit.Just 1) as Nothing | Just Nat
tag Just 1 as Nothing | Just Nat
tag Nothing as Nothing | Just Nat
get {foo=True, bar=False}.bar
get {foo=True, bar=False}.foo
get ((\u:Unit.((\n:Nat.True) 1, False)) Unit).0
get ((\u:Unit.((\n:Nat.True) 1, False)) Unit).1
get ((\u:Unit.((\n:Nat.True) 1, False)) Unit).1
get ((\u:Unit.((\n:Nat.True) 1, False)) Unit).0
get ((\u:Unit.((\n:Nat.True) 1, False)) Unit).0
get ((\u:Unit.((\n:Nat.True) 1, False)) Unit).0
get ((\u:Unit.((\n:Nat.True) 1, False)) Unit).0
:t get ((\u:Unit.((\n:Nat.True) 1, False)) Unit).0
:t ((\u:Unit.((\n:Nat.True) 1, False)) Unit)
(\u:Unit.((\n:Nat.True) 1, False)) Unit
(\u:Unit.((\n:Nat.True) 1, False))
get (\u:Unit.((\n:Nat.True) 1, False)).0
get ((\n:Nat.True) 1, False).0
get ((\n:Nat.True), False).0
get (True, False).0
:t get (True, False).0
:t get (True, False).0
get (True, False).0
(True, False)
if: (\n:Nat.True) 1 then: 1 else: 0
if: (\n:Nat.True) 1 then: (\n:Nat.n) 1 else: (\n:Nat.n) 0
if: (\n:Nat.True) 1 then: (\n:Nat.n) 1 else: (\n:Nat.n) 0
if: (\n:Nat.True) then: (\n:Nat.n) 1 else: (\n:Nat.n) 0
if: True then: (\n:Nat.n) 1 else: (\n:Nat.n) 0
if: True then: 1 else: 0
if: True then: (\n:Nat.n) 1 else: (\n:Nat.n) 0
if: True then: 1 else: 0
:t if: True then: 1 else: 0
if: True then: 1 else: 0
(True, False, (\n:Nat.n) 1, (\n:Nat.n) 3)
(True, False, (\n:Nat.n) 1, (\n:Nat.n) 3)
(True, False, (\n:Nat.n) 1, (\n:Nat.n) 3)
((\n:Nat.n) 1, (\n:Nat.n) 3)
((\n:Nat.n) 1, (\n:Nat.n) 3)
(True, False, (\n:Nat.n) 1, (\n:Nat.n) 3)
(True, False, (\n:Nat.n) 1)
(True, False, (\n:Nat.n))
(True, False)
<True, (\n:Nat.n) 1>
<True, (\n:Nat.n)>
<True, False>
(True, False)
True
(True, False, 1)
let x = (\n:Nat.n) 3 in x
let x = (\n:Nat.n) in S x
let x = (\n:Nat.n) 3 in S x
(\n:Nat.n) 3
(\n:Nat.n) 1
(\n:Nat.n)
(n:Nat.n)
(\n:Nat.n) 1
(tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
(tag Cons (1, tag Cons (2, tag Cons (3, tag Nil))) as mu.NatList: Nil | Cons (Nat, NatList))
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec isEven(rec : Nat -> Bool) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) in isEven 5
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec isEven(rec : Nat -> Bool) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) in isEven 4 
let isZero (n : Nat) = case n of Z => True | (S m) => False in let pred (n : Nat) = case n of Z => Z | (S m) => m in letrec isEven(rec : Nat -> Bool) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) in isEven 4
   in letrec isEven(rec : Nat -> Bool) (n : Nat) = if: isZero n then: True else: if: isZero (pred n) then: False else: rec (pred (pred n)) 
   in let pred (n : Nat) = case n of Z => Z | (S m) => m 
let isZero (n : Nat) = case n of Z => True | (S m) => False 
:t tag Just 32 as (Nothing | Just Nat)
:t tag Nothing as (Nothing | Just Nat)
tag Nothing as (Nothing | Just Nat)
:t (1, True, True)
:t (1, True)
(1, True)
:t 4
4
3
2
1
:t True
False
True
:t Unit
let x = {foo=tag Nothing as (Nothing | Just Nat)} in (get x.foo)
:t tag Nothing as (Nothing | Just Nat)
:t tag Nothing as (Nothing | Just Nat)
:t tag Nothing sa (Nothing | Just Nat)
:t tag Nothing (Nothing | Just Nat)
let x = {foo=tag Nothing as (Nothing | Just Nat)} in (get x.foo)
:t let x = {foo=tag Nothing as (Nothing | Just Nat)} in (get x.foo)
